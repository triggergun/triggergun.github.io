(window.webpackJsonp=window.webpackJsonp||[]).push([[366],{2104:function(a,t,e){"use strict";e.r(t);var l=e(18),r=Object(l.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"threadlocal为什么会内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal为什么会内存泄漏"}},[a._v("#")]),a._v(" ThreadLocal为什么会内存泄漏？")]),a._v(" "),t("p",[a._v("注意：不是因为key是弱引用。")]),a._v(" "),t("p",[t("strong",[a._v("理解关键点：")]),t("font",{attrs:{color:"red"}},[a._v("ThreadLocal的生命周期它是和线程绑定的。")])],1),a._v(" "),t("p",[a._v("问题1："),t("font",{attrs:{color:"blue"}},[a._v("那么ThreadLocal的数据存在哪里呢？")])],1),a._v(" "),t("p",[a._v("答：数据不存在ThreadLocal对象的本身，而是在每一个ThreadLocal对象里面它会有个ThreadLocalMap的一个私有变量。你可以把这个map想象成一个线程专属的一个"),t("font",{attrs:{color:"blud"}},[a._v("小仓库")]),a._v("。那么这就导致了一个关键问题。"),t("strong",[a._v("问题2的引出")])],1),a._v(" "),t("p",[a._v("问题2："),t("font",{attrs:{color:"blue"}},[a._v("如果线程本身它不结束，这个小仓库就会一直存在的一个问题！")])],1),a._v(" "),t("p",[a._v("答：想象一个场景假如我们在线程池里面去用ThreadLocal，那么这些工作线程会长期的存活着。反复的去执行任务就存问题了。")]),a._v(" "),t("p",[a._v("问题3："),t("font",{attrs:{color:"blue"}},[a._v("当你在线程外将某个ThreadLocal对象实例设置为null。希望它会被回收的时候发现它依然还占这内存。为什么会占这内存呢？")])],1),a._v(" "),t("p",[a._v("答：因为线程还在嘛。ThreadLocalMap还存在。map里面对应的那个ThreadLocal的引用也就还存在。这就造成了一堆你已经不再使用的"),t("font",{attrs:{color:"blud"}},[a._v("无效数据没法被回收")]),a._v("。导致了内存的泄漏问题。")],1),a._v(" "),t("p",[a._v("问题4："),t("font",{attrs:{color:"blue"}},[a._v("怎么缓解这个内存泄漏问题呢？")])],1),a._v(" "),t("p",[a._v("答：JDK的设计者引入了二个关键的机制。")]),a._v(" "),t("p",[a._v("**第一个关键的机制：**将map里面的key也就是ThreadLoca对象本身设计为弱引用。那么弱引用的作用就是我在回收的时候不管内存足部足。我都会被回收。解决了：线程还在，一旦我们将ThreadLoca的变量设置为null。那么这个key也会在GC的时候清理掉。map里面就对应的条目就会变为一个：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("key "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("value有值的一个状态。但是又引出了下一个问题。")]),a._v(" "),t("p",[a._v("问题5："),t("font",{attrs:{color:"blue"}},[a._v("那么key被回收了，value还在的问题！")])],1),a._v(" "),t("p",[a._v("**第二个关键的机制：**那么这些key为null的entry以及它们对应的value对象依然还占着内存的。所以它依然还会导致一个内存泄漏问题。所以在ThreadLoca内部它"),t("font",{attrs:{color:"blud"}},[a._v("内置了一些清理的机制")]),a._v("。比如说：set、get、remove方法的时候会顺带的将这些无效的key=null的一些条目给清理掉。但是这也绝对不能百分百的及时清理。")],1),a._v(" "),t("p",[a._v("不及时调用这些方法导致的问题：")]),a._v(" "),t("p",[a._v("数据会一直堆积在内存里面。")]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("最有效的解决办法")]),a._v(" "),t("p",[a._v("用完后及时的手动的去remove，remove以后这些对象都会被回收掉。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);