(window.webpackJsonp=window.webpackJsonp||[]).push([[248],{1672:function(a,t,s){"use strict";s.r(t);var v=s(25),_=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"所有权"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#所有权"}},[a._v("#")]),a._v(" 所有权")]),a._v(" "),t("h2",{attrs:{id:"什么是所有权"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是所有权"}},[a._v("#")]),a._v(" 什么是所有权？")]),a._v(" "),t("p",[a._v("rust将内存管理的工作都提前到了编译时。")]),a._v(" "),t("h2",{attrs:{id:"stack-vs-heap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stack-vs-heap"}},[a._v("#")]),a._v(" Stack VS Heap")]),a._v(" "),t("p",[a._v("因为指针是固定大小的，【在c语言中额是???还没有验证，可以大胆猜想下。】我可以把指针放到stack上面。")]),a._v(" "),t("ul",[t("li",[a._v("但如果想要实际的数据，你必须使用指针来定位。")])]),a._v(" "),t("p",[a._v("上面的过程，我们可以想象到饭店去吃饭，到达饭店之后表明我们都多少个人，需要多少位子。这个时候饭店的服务员会找到一张足够大的空卓子。然后将我们一起领过去入座就餐。即使有其他朋友来往，他们也可以通过询问我们位子来找到我们。")]),a._v(" "),t("ul",[t("li")]),a._v(" "),t("h3",{attrs:{id:"访问数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问数据"}},[a._v("#")]),a._v(" 访问数据")]),a._v(" "),t("p",[a._v("继续用上面饭店的案例来说：假设当时有许多桌的顾客都在等点菜。那么最高效的处理方式是？答：这个服务员等这桌顾客菜点完之后，在去处理下一桌的顾客点菜。如果这个桌刚点了一个菜，然会去另外一桌点一个，这样来回串这点那么它不得不浪费许多时间来往返这些桌子之间。")]),a._v(" "),t("h3",{attrs:{id:"函数调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数调用"}},[a._v("#")]),a._v(" 函数调用")]),a._v(" "),t("h3",{attrs:{id:"所有权存在的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#所有权存在的原因"}},[a._v("#")]),a._v(" 所有权存在的原因")]),a._v(" "),t("p",[a._v("所有权解决的问题：")]),a._v(" "),t("ul",[t("li",[a._v("跟踪代码的哪些部分正在使用heap 的哪些数据。")]),a._v(" "),t("li",[a._v("最小化heap上的重复数据量。")]),a._v(" "),t("li",[a._v("清理 heap 上未使用的数据以避免空间不足。")])]),a._v(" "),t("p",[a._v("一旦你懂的了所有权，那么就不需要经常去想 stack或 heap 了。")]),a._v(" "),t("p",[a._v("但是要知道管理 heap 数据是"),t("strong",[a._v("所有权")]),a._v("存在的原因，这有助于"),t("strong",[a._v("解释它")]),a._v("为什么会这样工作。")])])}),[],!1,null,null,null);t.default=_.exports}}]);