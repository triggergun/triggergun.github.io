# `method.getDeclaringClass()` 方法详解

## 1)**作用是什么？**

**`method.getDeclaringClass()` 用于获取声明该方法的类名全路径字符串**。它告诉你这个方法最初是在哪个类中定义的。

字符串的格式：

```shell
class xxx.xxx.xxClass
interface xxxx.xx.xx

class xxx.xxx.xxClass$xxx  // 内部类
interface xxxx.xx.xx$xxxx // 内部接口
```

## 2)**获取的是什么？**

| 场景                 | 声明类    | 实际调用类 | `getDeclaringClass()` 返回 |
| :------------------- | :-------- | :--------- | :------------------------- |
| 父类定义，子类继承   | 父类      | 子类对象   | **父类**                   |
| 接口定义，实现类实现 | 接口      | 实现类对象 | **接口**                   |
| 类自身定义           | 类自身    | 类自身对象 | **类自身**                 |
| 重写方法             | 父类/接口 | 子类对象   | **父类/接口**              |

**关键点**：返回的是**方法最初被声明的地方**，而不是实际调用的对象的类。

## 3)**完整代码案例**

```java
package demo06_mothd_test01;

import java.lang.reflect.Method;

public class GetDeclaringClassDemo {

    // 父类
    static class Animal {
        public void eat() {
            System.out.println("Animal eating...");
        }

        public void sleep() {
            System.out.println("Animal sleeping...");
        }

        private void privateMethod() {
            System.out.println("Animal private method");
        }
    }

    // 子类
    static class Dog extends Animal {
        @Override
        public void eat() {
            System.out.println("Dog eating...");
        }

        public void bark() {
            System.out.println("Dog barking...");
        }

        // 新增方法
        public void fetch() {
            System.out.println("Dog fetching...");
        }
    }

    // 接口
    interface Swimmable {
        void swim();

        // 默认的行为
        default void defaultSwim() {
            System.out.println("Default swimming...");
        }
    }

    // 实现类
    static class Fish implements Swimmable {
        @Override
        public void swim() {
            System.out.println("Fish swimming...");
        }

        public void breathe() {
            System.out.println("Fish breathing...");
        }
    }

    public static void main(String[] args) throws Exception {
        System.out.println("=== method.getDeclaringClass() 演示 ===\n");

        // 1. 继承场景
        System.out.println("1. 继承场景:");
        Dog dog = new Dog();
        System.out.println("dog class<?> :" + dog.getClass());
        Class<?> dogClass = dog.getClass();

        Method eatMethod = dogClass.getMethod("eat");
        Method sleepMethod = dogClass.getMethod("sleep");
        Method barkMethod = dogClass.getMethod("bark");
        Method fetchMethod = dogClass.getMethod("fetch");

        // 获取方法声明的类
        System.out.println("  eat()声明类: " + eatMethod.getDeclaringClass().getSimpleName());
        System.out.println("  eat()声明类 getDeclaringClass: " + eatMethod.getDeclaringClass());
        System.out.println("  sleep()声明类: " + sleepMethod.getDeclaringClass().getSimpleName());
        System.out.println("  sleep()声明类 getDeclaringClass: " + sleepMethod.getDeclaringClass());
        System.out.println("  bark()声明类: " + barkMethod.getDeclaringClass().getSimpleName());
        System.out.println("  fetch()声明类: " + fetchMethod.getDeclaringClass().getSimpleName());

        // 2. 接口场景
        System.out.println("\n2. 接口场景:");
        Fish fish = new Fish();
        Class<?> fishClass = fish.getClass();

        Method swimMethod = fishClass.getMethod("swim");
        // 接口中的方法
        Method defaultSwimMethod = fishClass.getMethod("defaultSwim");
        // 类中的方法，子类独有的方法。
        Method breatheMethod = fishClass.getMethod("breathe");

        System.out.println("  swim()声明类: " + swimMethod.getDeclaringClass().getSimpleName());
        System.out.println("  defaultSwim()声明类: " + defaultSwimMethod.getDeclaringClass().getSimpleName());
        System.out.println("  defaultSwim()声明类 getDeclaringClass: " + defaultSwimMethod.getDeclaringClass());
        System.out.println("  breathe()声明类: " + breatheMethod.getDeclaringClass().getSimpleName());

        // 3. 对比 getClass() 和 getDeclaringClass()
        System.out.println("\n3. 对比分析:");
        System.out.println("  狗对象.getClass(): " + dog.getClass().getSimpleName());
        System.out.println("  dog.eat()实际执行类: Dog");
        System.out.println("  eat()方法声明类: " + eatMethod.getDeclaringClass().getSimpleName());

        // 4. 多级继承
        System.out.println("\n4. 多级继承测试:");
        testMultiLevelInheritance();

        // 5. 实际应用
        System.out.println("\n5. 实际应用场景:");
        testPracticalUseCases();
    }

    static class GrandParent {
        public void grandParentMethod() {
        }
    }

    static class Parent extends GrandParent {
        @Override
        public void grandParentMethod() {
        }

        public void parentMethod() {
        }
    }

    static class Child extends Parent {
        @Override
        public void grandParentMethod() {
        }

        @Override
        public void parentMethod() {
        }

        public void childMethod() {
        }
    }

    static void testMultiLevelInheritance() throws Exception {
        Child child = new Child();
        Class<?> childClass = child.getClass();

        System.out.println("  Child对象实际类: " + childClass.getSimpleName());

        Method[] methods = childClass.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println("  方法: " + method.getName() +
                    ", 声明类: " + method.getDeclaringClass().getSimpleName());
        }

        // 获取继承的方法
        System.out.println("\n  继承的方法:");
        Method[] allMethods = childClass.getMethods();
        for (Method method : allMethods) {
            String methodName = method.getName();
            if (methodName.startsWith("grandParent") ||
                    methodName.startsWith("parent") ||
                    methodName.startsWith("child")) {
                System.out.println("  方法: " + methodName +
                        ", 声明类: " + method.getDeclaringClass().getSimpleName());
            }
        }
    }

    static void testPracticalUseCases() throws Exception {
        // 场景1：框架中判断方法来源
        System.out.println("  场景1 - 判断方法来源:");

        Dog dog = new Dog();
        Method eatMethod = dog.getClass().getMethod("eat");

        if (eatMethod.getDeclaringClass() == Animal.class) {
            System.out.println("    eat()方法定义在Animal类中（实际上定义在Dog，但Animal有声明）");
        } else if (eatMethod.getDeclaringClass() == Dog.class) {
            System.out.println("    eat()方法定义在Dog类中（正确！）");
        }

        Method sleepMethod = dog.getClass().getMethod("sleep");
        if (sleepMethod.getDeclaringClass() == Animal.class) {
            System.out.println("    sleep()方法定义在Animal类中（正确！）");
        }

        // 场景2：日志框架 - 记录方法来源
        System.out.println("\n  场景2 - 日志记录:");
        logMethodCall(dog, "eat");
        logMethodCall(dog, "sleep");
        logMethodCall(dog, "bark");

        // 场景3：权限控制 - 检查方法是否来自特定包
        System.out.println("\n  场景3 - 权限检查:");
        checkMethodPermission(eatMethod);
        checkMethodPermission(sleepMethod);

        // 场景4：序列化框架 - 处理继承的方法
        System.out.println("\n  场景4 - 序列化处理:");
        processMethodForSerialization(eatMethod);
        processMethodForSerialization(sleepMethod);
    }

    static void logMethodCall(Object obj, String methodName) throws Exception {
        Method method = obj.getClass().getMethod(methodName);
        System.out.println("    调用: " + methodName +
                "() [声明类: " + method.getDeclaringClass().getSimpleName() +
                ", 调用对象: " + obj.getClass().getSimpleName() + "]");
    }

    static void checkMethodPermission(Method method) {
        String packageName = method.getDeclaringClass().getPackage().getName();
        if (packageName.startsWith("java.") || packageName.startsWith("javax.")) {
            System.out.println("    警告: " + method.getName() +
                    "() 来自系统包 " + packageName + "，需要特殊权限");
        } else {
            System.out.println("    允许: " + method.getName() +
                    "() 来自应用包 " + packageName);
        }
    }

    static void processMethodForSerialization(Method method) {
        Class<?> declaringClass = method.getDeclaringClass();

        // 不序列化Object类的方法（如wait, notify等）
        if (declaringClass == Object.class) {
            System.out.println("    跳过: " + method.getName() + "() 来自Object类");
        }
        // 特殊处理来自父类的方法
        else if (!declaringClass.equals(method.getClass())) {
            System.out.println("    处理继承方法: " + method.getName() +
                    "() [声明于: " + declaringClass.getSimpleName() + "]");
        }
        // 处理自身声明的方法
        else {
            System.out.println("    处理自身方法: " + method.getName() + "()");
        }
    }
}
```

输出结果：

```
=== method.getDeclaringClass() 演示 ===

1. 继承场景:
dog class<?> :class demo06_mothd_test01.GetDeclaringClassDemo$Dog
  eat()声明类: Dog
  eat()声明类 getDeclaringClass: class demo06_mothd_test01.GetDeclaringClassDemo$Dog
  sleep()声明类: Animal
  sleep()声明类 getDeclaringClass: class demo06_mothd_test01.GetDeclaringClassDemo$Animal
  bark()声明类: Dog
  fetch()声明类: Dog

2. 接口场景:
  swim()声明类: Fish
  defaultSwim()声明类: Swimmable
  defaultSwim()声明类 getDeclaringClass: interface demo06_mothd_test01.GetDeclaringClassDemo$Swimmable
  breathe()声明类: Fish

3. 对比分析:
  狗对象.getClass(): Dog
  dog.eat()实际执行类: Dog
  eat()方法声明类: Dog

4. 多级继承测试:
  Child对象实际类: Child
  方法: grandParentMethod, 声明类: Child
  方法: childMethod, 声明类: Child
  方法: parentMethod, 声明类: Child

  继承的方法:
  方法: grandParentMethod, 声明类: Child
  方法: childMethod, 声明类: Child
  方法: parentMethod, 声明类: Child

5. 实际应用场景:
  场景1 - 判断方法来源:
    eat()方法定义在Dog类中（正确！）
    sleep()方法定义在Animal类中（正确！）

  场景2 - 日志记录:
    调用: eat() [声明类: Dog, 调用对象: Dog]
    调用: sleep() [声明类: Animal, 调用对象: Dog]
    调用: bark() [声明类: Dog, 调用对象: Dog]

  场景3 - 权限检查:
    允许: eat() 来自应用包 demo06_mothd_test01
    允许: sleep() 来自应用包 demo06_mothd_test01

  场景4 - 序列化处理:
    处理继承方法: eat() [声明于: Dog]
    处理继承方法: sleep() [声明于: Animal]
```



## 4)**为什么有这个方法？**

**核心原因**：**反射需要知道方法的真正来源**

### 1. **解决继承中的方法来源问题**

```java
// 问题：通过子类对象获取的eat()方法，到底是谁定义的？
Dog dog = new Dog();
Method eatMethod = dog.getClass().getMethod("eat");

// 通过getDeclaringClass()我们知道：
// - 如果是Animal，说明Dog没有重写，用的是父类实现
// - 如果是Dog，说明Dog重写了这个方法
Class<?> declaringClass = eatMethod.getDeclaringClass();
```



### 2. **框架开发的真实需求**

**Spring框架中的使用场景**：

```java
// Spring AOP 判断方法是否需要拦截
private boolean shouldIntercept(Method method) {
    // 只拦截在目标类中声明的方法，不拦截继承的方法
    return method.getDeclaringClass() != Object.class && 
           !Modifier.isPrivate(method.getModifiers());
}

// Spring事务管理
@Transactional
public class UserService {
    public void saveUser(User user) {
        // 这个方法声明在UserService中
        // getDeclaringClass()返回UserService.class
    }
}
```



**JUnit测试框架**：

```java
// JUnit 4中查找测试方法
public List<Method> getTestMethods(Class<?> testClass) {
    List<Method> methods = new ArrayList<>();
    for (Method method : testClass.getMethods()) {
        // 只收集在当前测试类中声明的测试方法
        // 避免收集到父类的测试方法
        if (method.isAnnotationPresent(Test.class) && 
            method.getDeclaringClass() == testClass) {
            methods.add(method);
        }
    }
    return methods;
}
```



**Hibernate/MyBatis等ORM框架**：

```
// MyBatis Mapper接口方法处理
public void processMapperMethod(Method method) {
    Class<?> declaringClass = method.getDeclaringClass();
    
    // 检查方法是否来自Mapper接口
    if (declaringClass.isInterface()) {
        // 这是接口中声明的方法，需要生成实现
        generateImplementation(method);
    } else {
        // 这是默认方法或Object方法
        handleDefaultMethod(method);
    }
}
```



### 3. **实际应用价值**

| 应用场景     | 为什么需要             | 示例                             |
| :----------- | :--------------------- | :------------------------------- |
| **AOP拦截**  | 避免拦截Object类的方法 | `wait()`, `notify()`等不应被拦截 |
| **序列化**   | 区分自身方法和继承方法 | 继承的方法可能不需要序列化       |
| **日志记录** | 准确记录方法来源       | 知道方法是来自框架还是业务代码   |
| **权限控制** | 根据方法来源控制权限   | 系统方法需要更高权限             |
| **代码生成** | 知道在哪里生成代码     | 接口方法需要生成实现             |

### 4. **与getClass()的对比**

```java
Dog dog = new Dog();

// dog.getClass() 返回的是运行时类型
System.out.println(dog.getClass());          // 输出: Dog

// method.getDeclaringClass() 返回的是方法定义时的类型
Method eatMethod = dog.getClass().getMethod("eat");
System.out.println(eatMethod.getDeclaringClass()); // 输出: Animal 或 Dog
```

### 5. **设计哲学**

**Java反射API的设计者需要考虑**：

- 方法可能来自父类、接口、或自身
- 框架需要知道方法的"原始出处"
- 有些操作（如代理、AOP）只应对特定来源的方法生效

**没有这个方法会怎样？**

- 框架无法区分继承的方法和自身声明的方法
- AOP可能错误拦截Object类的方法
- 序列化会处理不该处理的方法
- 调试时无法准确知道方法来源

------

## 5)**实用技巧**

### 1. **判断方法是否被重写**

```java
public static boolean isMethodOverridden(Class<?> clazz, String methodName) throws Exception {
    Method method = clazz.getMethod(methodName);
    return method.getDeclaringClass() != method.getClass();
}
```



### 2. **过滤掉Object类的方法**

```java
public static List<Method> getBusinessMethods(Class<?> clazz) {
    return Arrays.stream(clazz.getMethods())
        .filter(m -> m.getDeclaringClass() != Object.class)
        .collect(Collectors.toList());
}
```



### 3. **框架中的典型使用**

```java
// 在Spring的AbstractAutoProxyCreator中
protected boolean shouldProxyTargetClass(
    BeanDefinition beanDefinition, Class<?> beanClass) {
    
    for (Method method : beanClass.getMethods()) {
        // 只考虑在当前类中声明的方法
        if (method.getDeclaringClass() == beanClass) {
            // 检查是否需要代理
            if (isMethodCandidateForProxy(method)) {
                return true;
            }
        }
    }
    return false;
}
```



## 6)**总结**

**`method.getDeclaringClass()` 的核心价值**：

1. **追溯方法来源**：在复杂的继承体系中，准确知道方法定义的位置
2. **框架基础**：是Spring、Hibernate、JUnit等框架正常运行的基础
3. **精确控制**：允许框架对来自不同源头的方法进行差异化处理
4. **反射完整性**：使反射API能够完整描述方法的元信息

**一句话概括**：**"反射中的家谱查询工具"**，帮你找到方法在类继承树中的真正出生地。

