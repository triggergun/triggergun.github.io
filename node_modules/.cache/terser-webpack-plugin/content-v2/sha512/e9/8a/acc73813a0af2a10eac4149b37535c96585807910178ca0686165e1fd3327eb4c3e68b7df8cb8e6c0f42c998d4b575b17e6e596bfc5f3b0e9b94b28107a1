{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[387],{2134:function(t,v,_){\"use strict\";_.r(v);var a=_(18),r=Object(a.a)({},(function(){var t=this,v=t._self._c;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"什么是springaop\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是springaop\"}},[t._v(\"#\")]),t._v(\" 什么是springAOP？\")]),t._v(\" \"),v(\"h2\",{attrs:{id:\"aop理解回答\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aop理解回答\"}},[t._v(\"#\")]),t._v(\" AOP理解回答\")]),t._v(\" \"),v(\"p\",[t._v(\"AOP是面向切面编程。是在不改变业务代码前提下把哪些通用逻辑抽出来，统一处理的一种思想。\")]),t._v(\" \"),v(\"p\",[t._v(\"比如：日志（ruoyi框架有应用）、事务、安全校验、redis的lua脚本限流（ruoyi框架有应用）这些都和业务没有关系但是很多方法都得实现。写一遍又一遍太蠢了。\")]),t._v(\" \"),v(\"p\",[t._v(\"AOP的核心思想是：用代理在方法调用的前后自动插入逻辑。举例子：你有一堆addXxxx()方法。现在想统一记录入参与出餐日志不用每一个地方都手写打印。springAOP会在它外面一层代理。调用的其实就是代理方法。他先执行日志逻辑，再去调用真正的addXxxx()方法。——这个就是切面的本质。\")]),t._v(\" \"),v(\"h2\",{attrs:{id:\"aop的核心概念\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aop的核心概念\"}},[t._v(\"#\")]),t._v(\" AOP的核心概念\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"切面：\")])]),t._v(\" \"),v(\"p\",[t._v(\"切面是功能模块，比如日志切面。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"通知：\")])]),t._v(\" \"),v(\"p\",[t._v(\"通知是执行时机，比如Before、After。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"连接点：\")])]),t._v(\" \"),v(\"p\",[t._v(\"连接点是程序所有能插刀的地方。比如方法执行、异常抛出。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"切入点：\")])]),t._v(\" \"),v(\"p\",[t._v(\"切入点是你选中要插刀的地方。比如：拦截service包下的所有方法。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"织入：\")])]),t._v(\" \"),v(\"p\",[t._v(\"织入就是把这段逻辑塞进去的过程。\")]),t._v(\" \"),v(\"p\",[t._v(\"最后：\")]),t._v(\" \"),v(\"p\",[t._v(\"springAOP用的是动态代理底层用JDK或者cglib在运行时织入逻辑。还有一个aspect的静态织入。是在编译期或者类加载期织入。\")]),t._v(\" \"),v(\"h2\",{attrs:{id:\"aop的必知必会\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aop的必知必会\"}},[t._v(\"#\")]),t._v(\" AOP的必知必会\")]),t._v(\" \"),v(\"ol\",[v(\"li\",[t._v(\"AOP是面向切面编程，是对面向OOP编程的一种补充。不是替代。\")]),t._v(\" \"),v(\"li\",[t._v(\"AOP底层靠代理机制织入逻辑，不同框架的织入时机不一样。\")]),t._v(\" \"),v(\"li\",[t._v(\"springAOP是运行时动态代理。（分JDK或cglib）。AspectJ是编译期静态织入。\")])])])}),[],!1,null,null,null);v.default=r.exports}}]);","extractedComments":[]}