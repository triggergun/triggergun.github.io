{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[411],{2188:function(s,t,e){\"use strict\";e.r(t);var r=e(18),a=Object(r.a)({},(function(){var s=this,t=s._self._c;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"实际开发过程中-怎么防止接口重复提交\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实际开发过程中-怎么防止接口重复提交\"}},[s._v(\"#\")]),s._v(\" 实际开发过程中，怎么防止接口重复提交？\")]),s._v(\" \"),t(\"p\",[s._v(\"这个问题涉及的知识点非常的广。解决的方案有许多。下面给出了逻辑上说的过去的方案。缺乏实战。都是停留在理论上。\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"涉及的问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#涉及的问题\"}},[s._v(\"#\")]),s._v(\" 涉及的问题\")]),s._v(\" \"),t(\"p\",[s._v(\"比如用户重复点击个按钮，导致重复订单创建或者重复扣费。\")]),s._v(\" \"),t(\"p\",[s._v(\"核心是考察接口的幂等性设计。——所谓幂等性，就是让一个接口的多次调用对数据只产生一次影响。\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"理论上的解决方案\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#理论上的解决方案\"}},[s._v(\"#\")]),s._v(\" 理论上的解决方案\")]),s._v(\" \"),t(\"p\",[s._v(\"有三种方案。\")]),s._v(\" \"),t(\"p\",[s._v(\"第一个，你可以利用数据库的唯一索引，一旦重复创建相同数据，就可以触发索引的冲突异常。这种适合创建类的场景。\")]),s._v(\" \"),t(\"p\",[s._v(\"第二个，你可以\"),t(\"font\",{attrs:{color:\"red\"}},[s._v(\"基于 Redis 来实现\")]),s._v(\"。用户的请求到达以后，你用业务标志加上用户 ID 来生成一个唯一的 key。通过 SETNX 命令来去尝试获得锁，\"),t(\"font\",{attrs:{color:\"red\"}},[s._v(\"获得锁成功\")]),s._v(\"就执行业务逻辑。\")],1),s._v(\" \"),t(\"p\",[s._v(\"假如：用业务标志是user，用户id为：1.则：user:1就是redis的key。\")]),s._v(\" \"),t(\"div\",{staticClass:\"language-shell line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[t(\"code\",[s._v(\"user:1\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\")])]),t(\"p\",[s._v(\"redis的SETNX命令作用是什么？\")]),s._v(\" \"),t(\"p\",[s._v(\"第三个，你可以前端去携带一个唯一的ID，后端接收到以后呢，去先查缓存或者数据库，判断这个 ID 是不是已经处理过了。如果已经处理了，就直接返回结果，不重复执行。\")])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}